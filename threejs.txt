# Using threejs with the help of a cdn 
-> Search for threejs cdn there select the version as 16.0.0 and select threemin.js script tag and paste it in our body tag before the sript.js.
-> We are ready to use threejs.

# Creating a scene
const scene = new THREE.Scene(); // This will create a scene we can view the elements in the scene.
-> If we want to see anything we have to add it into the scene.

# Camera
const camera = new THREE.PerspectiveCamera( fov, aspect ratio, near, far );
-> PerspectiveCamera it is basically like our eyes.
-> fov: it is the view range of our eye how much we can see .Jitna fov kam hoga hum utna hi jaada zoomed in hai.Fov jitna jada hoga hum utna hi jada dekh skte hai.
-> Aspect Ratio : window.innerWidth / window.innerHeight // camera should view how much height and width.
-> Near: camera kitne pass waale object ko dekhe.
-> Far: camera kitne dur ki cheejein dikhayege
sytax: 
const camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );

const geometry = new THREE.BoxGeometry( 1, 1, 1 );// This tells us about the type of geometry we want to use.Here it is BoxGeometry(x,y,z)

const material = new THREE.MeshBasicMaterial( { color: "yellow", wireframe: true } );// The material through which we are gona wrap our geometry is material
const cube = new THREE.Mesh( geometry, material );
//This is putting material onto the geometry ( Ye basically geometry ko material se poora cover krr rha hai)
scene.add( cube );// Adding the cube to our scene.

camera.position.z = 5; // Moving the camera back so that we can view the cube because we were inside the cube before but when we move camera back then we move out of the cube.

const canvas = document.querySelector("canvas");
const renderer = new THREE.WebGLRenderer({ canvas });//Renderer is basically a camera which will show us our scene on canvas or we can say it will reneder our scene
renderer.setSize( window.innerWidth, window.innerHeight ); //here we are setting the size of renderer how much width and height renderer should render/ show.

function animate() { 
    window.requestAnimationFrame(animate);
	renderer.render( scene, camera );
    cube.rotation.x += 0.01;
    cube.rotation.y += 0.01;
} // for moving the element we create animate function 
renderer.setAnimationLoop( animate );// this will keep repeating the animation again and again

cube.rotation.x += 0.01;
cube.rotation.y += 0.01;// This will rotate our cube in x and y axis

# Box geometry 
-> BoxGeometry is a geometry class for a rectangular cuboid with a given 'width', 'height', and 'depth'. On creation, the cuboid is centred on the origin, with each edge parallel to one of the axes.
-> It is created using the properties of buffer geometry.
-> Box Geometry can use all the properties of the buffer geometry also.
-> Constructor 
// BoxGeometry(width : Float, height : Float, depth : Float, widthSegments : Integer, heightSegments : Integer, depthSegments : Integer)
// width — Width; that is, the length of the edges parallel to the X axis. Optional; defaults to 1.
// height — Height; that is, the length of the edges parallel to the Y axis. Optional; defaults to 1.
// depth — Depth; that is, the length of the edges parallel to the Z axis. Optional; defaults to 1.
// widthSegments — Number of segmented rectangular faces along the width of the sides. Optional; defaults to 1.
// heightSegments — Number of segmented rectangular faces along the height of the sides. Optional; defaults to 1.
// depthSegments — Number of segmented rectangular faces along the depth of the sides. Optional; defaults to 1.

# Transformation ,Scaling and rotation
cube.position.x = 1; // this will move the cube by 1 in x axis.
cube.position.y = 1; // this will move the cube by 1 in Y axis.
cube.position.z = 1; // this will move the cube by 1 in z axis.

cube.rotation.x += 1; // this will rotate the cube around x axis by 1 .
cube.rotation.y += 1; // this will rotate the cube around y axis by 1 .
cube.rotation.z += 1; // this will rotate the cube around z axis.
renderer.render(scene, camera); // this line will keep on printing/ rendering the scene again and again after each of the rotation so this will make the cube rotate;

cube.scale.x = 3; // this will scale the cube in x axis
cube.scale.y = 3; // this will scale the cube in y axis
cube.scale.z = 3; // this will scale the cube in z axis

# Vite setup of Threejs 
// Integrating Tailwind css with Vite
-> Using vite we will create a new vanilla js folder 
syntax : npm create vite@latest 
select vanilla -> javascript 
cd folder 
npm install 
npm run dev 
// This will create the vanilla js file using vite 
-> Delete everything from main.js index.html and setup delete counter.js 
-> create a index.css file 
// Install Tailwind CSS 
-> Go to tailwind website select framework as vite and install packages needed 

-> To integrate Tailwind we need to use a script so that our tailwind get compiled everytime we change/add anything for that we need to install this package below
npm install tailwindcss postcss-cli autoprefixer
// IN package.json in script section add 
"watch": "postcss index.css -o style.css --watch", // using watch we can run this "postcss index.css -o style.css --watch" command this will keep looking on our code and pick tailwind code from index.css and give its output on style.css

npm run watch on one terminal and npm run dev on the other terminal .
-> npm run watch will 

# Installing ThreeJS with vite 
npm i three // this will install all threejs package
-> Link main.js to our index.html file set type = "module" and then we can start using threejs package

// main.js
import * as THREE from "three";

const scene = new THREE.Scene();

const camera = new THREE.PerspectiveCamera(75,window.innerWidth / window.innerHeight, 0.1, 20);

const geometry = new THREE.BoxGeometry(1,1,1,6,6,6);
const material = new THREE.MeshBasicMaterial({color: "red", wireframe: true});
const cube= new THREE.Mesh(geometry,material);

camera.position.z = 5;


scene.add(cube);

const canvas = document.querySelector("canvas");
const renderer = new THREE.WebGLRenderer({canvas});
renderer.setSize( window.innerWidth, window.innerHeight );
renderer.render(scene, camera);

function animate(){
    window.requestAnimationFrame(animate);
    cube.rotation.y += 0.01;
    renderer.render(scene, camera);
}

animate();

# Rotation and grouping in ThreeJS
-> In ThreeJS 90 Degree = 1.57
180 Degree = 3.14
270 Degree = 1.57*3
360 Degree = 1.57*4
// So if we want to rotate the element 90 deg then we can rotate it by using Math.PI / 2; This will rotate the element by 90deg
90 = pi/2
180 = pi
270 = (pi/2)*3

# Group 
-> If we have two or more elements and we want to move the elements togther then we can group them.
const group = new THREE.Group();
group.add(cube);
group.add(sphere);

scene.add(group); // this will add the gropu of elements to the scene

# Animations in ThreeJS
-> If we have two or more elements and we want to move the elements then we create an animation function that will move the elements.
-> FPS : frame per second this means how much frames / images it can take in 1second.
Eg: 60FPS = 60 Frames in 1sec.
// Animate function 
function animate(){
    window.requestAnimationFrame(animate);
    
}

animate();

-> window.requestAnimationFrame(animate);// this will run the animate function for every frame. In 1 sec 60 times the animate function will run

Note : tmhari website ka animation code kissi ke laptop me tezz chlega kyoki vo laptop jada fps ka hai aur purane laptop prr slow chlega and we don't want this to happen. For this we have a way in threejs to avoid it.
let clock = new THREE.Clock();// create clock before the animate function using this clock we will return time because time always remain same for all of us.
mesh.rotation.y = clock.getElapsedTime();// It tells us how much time has been passed ,inside animate function
// If we want to move it fast we can multiply it with values
Eg: mesh.rotation.y = clock.getElapsedTime() * 2;

# Understanding Geometry in ThreeJS 
// Box Geometry 
-> BoxGeometry is a geometry class for a rectangular cuboid with a given 'width', 'height', and 'depth'. On creation, the cuboid is centred on the origin, with each edge parallel to one of the axes.
-> Constructor 
   BoxGeometry(width : Float, height : Float, depth : Float, widthSegments : Integer, heightSegments : Integer, depthSegments : Integer)

width — Width; that is, the length of the edges parallel to the X axis. Optional; defaults to 1.
height — Height; that is, the length of the edges parallel to the Y axis. Optional; defaults to 1.
depth — Depth; that is, the length of the edges parallel to the Z axis. Optional; defaults to 1.
widthSegments — Number of segmented rectangular faces along the width of the sides. Optional; defaults to 1.
heightSegments — Number of segmented rectangular faces along the height of the sides. Optional; defaults to 1.
depthSegments — Number of segmented rectangular faces along the depth of the sides. Optional; defaults to 1.

// Capsule Geometry 
-> CapsuleGeometry is a geometry class for a capsule with given radii and height. It is constructed using a lathe.
-> Constructor
   CapsuleGeometry(radius : Float, length : Float, capSegments : Integer, radialSegments : Integer)
radius — Radius of the capsule. Optional; defaults to 1.
length — Length of the middle section. Optional; defaults to 1.
capSegments — Number of curve segments used to build the caps. Optional; defaults to 4.
radialSegments — Number of segmented faces around the circumference of the capsule. Optional; defaults to 8.

// Cone Geometry 
-> A class for generating cone geometry.
-> Constructor 
   ConeGeometry(radius : Float, height : Float, radialSegments : Integer, heightSegments : Integer, openEnded : Boolean, thetaStart : Float, thetaLength : Float)
radius — Radius of the cone base. Default is 1.
height — Height of the cone. Default is 1.
radialSegments — Number of segmented faces around the circumference of the cone. Default is 32
heightSegments — Number of rows of faces along the height of the cone. Default is 1.
openEnded — A Boolean indicating whether the base of the cone is open or capped. Default is false, meaning capped.
thetaStart — Start angle for first segment, default = 0 (three o'clock position).
thetaLength — The central angle, often called theta, of the circular sector. The default is 2*Pi, which makes for a complete cone.

// There are many more geometries go and visit the threejs docs.

# Buffer Geometry 
-> A representation of mesh, line, or point geometry. Includes vertex positions, face indices, normals, colors, UVs, and custom attributes within buffers, reducing the cost of passing all this data to the GPU.
const geometry = new THREE.BufferGeometry();

// create a simple square shape. We duplicate the top left and bottom right
// vertices because each vertex needs to appear once per triangle.
const vertices = new Float32Array( [
	-1.0, -1.0,  1.0, // v0
	 1.0, -1.0,  1.0, // v1
	 1.0,  1.0,  1.0, // v2

	 1.0,  1.0,  1.0, // v3
	-1.0,  1.0,  1.0, // v4
	-1.0, -1.0,  1.0  // v5
] );

// v0,v1,v2 will create one phase v3,v4,v5 will create another phase.

// itemSize = 3 because there are 3 values (components) per vertex
geometry.setAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
const material = new THREE.MeshBasicMaterial( { color: 0xff0000 } );
const mesh = new THREE.Mesh( geometry, material );

-> In threejs every thing is made using a triangle for creating a triangle we need 3 points for one poiny we have to give the value (x,y,z) value.
-> In buffer geometry we give points and by joining points we create the element or object.

# Introduction to materials in threejs
-> Materials describe the appearance of objects. They are defined in a (mostly) renderer-independent way, so you don't have to rewrite materials if you decide to use a different renderer.

# MeshBasicMaterial
-> A material for drawing geometries in a simple shaded (flat or wireframe) way.
-> This material is not affected by lights.
// Constructor 
-> MeshBasicMaterial( parameters : Object )
   //parameters - (optional) an object with one or more properties defining the material's appearance. Any property of the material (including any property inherited from Material) can be passed in here.

# MeshStandardMaterial
-> A standard physically based material, using Metallic-Roughness workflow.
-> Physically based rendering (PBR) has recently become the standard in many 3D applications, such as Unity, Unreal and 3D Studio Max.
-> This approach differs from older approaches in that instead of using approximations for the way in which light interacts with a surface, a physically correct model is used. The idea is that, instead of tweaking materials to look good under specific lighting, a material can be created that will react 'correctly' under all lighting scenarios.
-> In practice this gives a more accurate and realistic looking result than the MeshLambertMaterial or MeshPhongMaterial, at the cost of being somewhat more computationally expensive. MeshStandardMaterial uses per-fragment shading.
-> Note that for best results you should always specify an environment map when using this material.
// Constructor 
-> MeshStandardMaterial( parameters : Object )
parameters - (optional) an object with one or more properties defining the material's appearance. Any property of the material (including any property inherited from Material) can be passed in here.
-> Without light we can't use the MeshStandardMaterial.
// Creating light 
const light = new THREE.DirectionalLight("white", 2);
light.position.set(1,1,1);
scene.add(light);

const helper = new THREE.DirectionalLightHelper( light, .8 );
scene.add( helper ); //helper will tell use from where light is created or coming from

# MeshNormalMaterial 
-> A material that maps the normal vectors to RGB colors.
// Constructor 
-> MeshNormalMaterial( parameters : Object )
parameters - (optional) an object with one or more properties defining the material's appearance. Any property of the material (including any property inherited from Material) can be passed in here.

# MeshPhysicalMaterial
-> An extension of the MeshStandardMaterial, providing more advanced physically-based rendering properties:
-> Anisotropy: Ability to represent the anisotropic property of materials as observable with brushed metals.
-> Clearcoat: Some materials — like car paints, carbon fiber, and wet surfaces — require a clear, reflective layer on top of another layer that may be irregular or rough. Clearcoat approximates this effect, without the need for a separate transparent surface.
-> Iridescence: Allows to render the effect where hue varies depending on the viewing angle and illumination angle. This can be seen on soap bubbles, oil films, or on the wings of many insects.
-> Physically-based transparency: One limitation of .opacity is that highly transparent materials are less reflective. Physically-based .transmission provides a more realistic option for thin, transparent surfaces like glass.
-> Advanced reflectivity: More flexible reflectivity for non-metallic materials.
-> Sheen: Can be used for representing cloth and fabric materials.
-> As a result of these complex shading features, MeshPhysicalMaterial has a higher performance cost, per pixel, than other three.js materials. Most effects are disabled by default, and add cost as they are enabled. For best results, always specify an environment map when using this material.
// Constructor 
MeshPhysicalMaterial( parameters : Object )
parameters - (optional) an object with one or more properties defining the material's appearance. Any property of the material (including any property inherited from Material and MeshStandardMaterial) can be passed in here.

# Texture
let textureLoader = new THREE.TextureLoader();// This single textureLoader is used to load the texture. We can add multiple texture using the single textureLoader.
let tex = textureLoader.load("/public/earthmap1k.jpg");
const material = new THREE.MeshPhysicalMaterial({map: tex});// Using the map property of the material add the texture to the material

# Using HDRI for realistic lighting in threejs
tex.colorSpace = THREE.ColorSpace; // using this the colors will look properly
// Ploy haven 
-> When we go inside this website we can use the HDRI's we will cover it in lights section too. 
-> Select outdoor then select natural lighting
-> We get various lighting options and we can use them in our project
-> copy the link address.
For loading it we need RGBELoader this will load the HDRI
import { RGBELoader } from "three/addons/loaders/RGBELoader.js";

let hdri = new RGBELoader();
hdri.load("https://dl.polyhaven.org/file/ph-assets/HDRIs/exr/4k/buikslotermeerplein_4k.exr", function(hdritexture){
    hdritexture.mapping = THREE.EquirectangularReflectionMapping;
    scene.environment = hdritexture
}
);

# Alphamap
-> alphamap will display the white part and hide the black part of the image if we use a black and white image.
let tex2 = textureLoader.load("https://www.shutterstock.com/image-photo/isolated-white-clouds-on-black-260nw-684470536.jpg");
tex2.colorSpace = THREE.SRGBColorSpace;
const material2 = new THREE.MeshPhysicalMaterial({alphaMap: tex2});
material2.transparent = true; 

# Mouse Movement
// lookAt 
-> It is a part of object 3D.
Eg: mesh.lookAt(-1,1,0) // this will make the object look at the given position.
But we should not pass the position like this we should pass it in 
mesh.lookAt(new THREE.Vector3(coordinate.x,coordinate.y,coordinate.z))
-> So this is how we can make a object look at any point or any position .

# Moving with Mouse
const mouse = {
  x:0,
  y:0,
};

window.addEventListener("mousemove", function (e) {
  mouse.x = e.clientX / window.innerWidth;
  mouse.y = e.clientY / window.innerHeight;
  console.log(e.clientX,e.clientY);
});

function animate(){
    window.requestAnimationFrame(animate);
    // cube.rotation.y += 0.01;
    cube.lookAt(new THREE.Vector3(mouse.x-.5,-mouse.y+.5,1));
    controls.update();
    renderer.render(scene, camera);
}

animate();
-> mouse.x-.5,-mouse.y+.5,1 
// As we know that three js works on both positive and negative coordinates so we need to update y as negative so that it works properly
// we have subtracted -.5 so that it starts from -.5 to +.5 and move in both x and -x direction properly(similarly for y also)

# Making your threejs scene Responsive 
window.addEventListener("resize", function (e) {
  camera.aspect = window.innerWidth / window.innerHeight;
  renderer.setSize( window.innerWidth, window.innerHeight);
  camera.updateProjectionMatrix();
});
// Using this we can make our scene Responsive

# Understanding Device Pixel Ratio in ThreeJS 
-> Pixel color krna and draw krna pixel par threejs uses GPU
-> Device pixel ratio (DPR) is the ratio between the physical pixels on a device's screen and the logical pixel.
-> DPR is useful for dealing with the difference between rendering on a standard display versus a HiDPI or Retina display. For example, HiDPI and Retina displays use more screen pixels to draw the same objects, resulting in a sharper image
-> You can use the window.devicePixelRatio property to determine the pixel density of a device. Most devices have a DPR between 1.0 and 4.0, but the ratio doesn't have to be a whole number.
-> Mostly use device pixel ratio between 1 to 2 more the DPR more GPU it will need.
Eg: renderer.setPixelRatio(window.devicePixelRatio); 
// If we do this then it will set the Pixel ratio as the DPR of our device.
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // This will select the minimum pixel so that more GPU should not be needed.

# Orbit controls
->